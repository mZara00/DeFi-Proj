pragma solidity ^0.8.16; //dont forget to compile with the version we use here.

contract OurToken {
    string public name; //first we make sure that both the name and symbol are public, otherwise no one will be able to see the token.;
    string public symbol;
    uint8 public decimals; //in order to count for decimals. Since when working with Solidity we have to count for possible truncation (floating point) errors.
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf; //mapping of all the accounts with their respective balances
    mapping(address => mapping(address => uint256)) public allowance; // here we nest the address of the person who is managing the tokens (not the owners). uint256 here represents the quantity of tokens we are allowing in our model.

    constructor () public {
        name = "Dodge Coin";
        symbol = "DC";
        decimals = 18;
        totalSupply = 100 * (uint256(10) ** decimals); //our number of tokens (100) multiplied by 10^10 to the power of the number of decimals we just introduced
        balanceOf[msg.sender] = totalSupply; //owner. From here we can start transfering the tokens with other people.
    }


    event Transfer(address indexed _from, address indexed _to, uint256 _value); //here we define an event where we allow people to exchange tokens, address _from is the sender and _to is the receiver. Here we account again for floating points.
    event Approval(address indexed _owner, address indexed _spender, uint256 _value); //here we define an event where we allow someone to manage the tokens aka. to send them 

    function transfer(address _to, uint256 _value) public returns(bool success) { //function where the input is the direction to where you send the tokens, value = # tokens you send, it will be a public function and it will return "success"
    require(balanceOf[msg.sender] >= _value); //here we make sure that the balance of the sender is greater or equal to the value he will be sending
    balanceOf[msg.sender] -= _value; //to the balance of the person sending the tokens, we substract the value he is sending
    balanceOf[_to] += _value; //we add the new amount of tokens to the person receiving them.
    emit Transfer(msg.sender, _to, _value); //here we call the event; we transfer the message (value of the sender _from) to the new account (_to) and its value in floating points.
    return true; //by calling return, we conclude with our first task of being able to send tokens among different accounts.
    } 

    function approve(address _spender, uint256 _value) public returns (bool success) { //hereby we authorize someone that can manage the tokens
    allowance [msg.sender][_spender] = _value; //hereby we assign the person who is authorized to manage the tokens, and how many tokens they can manage.
    emit Approval(msg.sender, _spender, _value); //we approve the event where we are the owners, the person authorized is the spender, and the value...
    return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { //After we have an authorized person we then allow that person to actually make use of its right to manage the tokens. we call this function transferFrom
        require(balanceOf[_from] >= _value); //the balance. where the tokens come from has to have enough tokens.
        require(allowance[_from][msg.sender] >= _value); // 
        balanceOf[_from] -= _value; //new balance of the sender
        balanceOf[_to] += _value; //new balance of the receiver
        allowance[_from][msg.sender] -= _value; //we do this in order to reduce the # of tokens the person is allowed to manage. Otherwise they could manage more tokens than there are available so to say.
        emit Transfer(_from, _to, _value); //same business as before
        return true;
    }
}


